/* NerveNet ver.0.1.0  (c) 2013 Meathill  MIT*/
!function (a, b) {
  function c(a) {
    return h.dir + "/" + a.split(".").join("/") + ".js"
  }

  function d(a, b) {
    b = b || "";
    var c = document.createElement("script");
    c.className = "nervenet " + b, c.innerHTML = a, p ? o.insertBefore(c, p) : o.appendChild(c)
  }

  function e(a) {
    return"function" == typeof a
  }

  function f(a) {
    return"isArray"in Array ? Array.isArray(a) : "[object Array]" === Object.prototype.toString.call(a)
  }

  b.Nervenet = a;
  var g = {};
  a.VERSION = "0.1.0", a.createContext = function () {
    return new i
  }, a.createNameSpace = function (a, c) {
    var d = a.split("."), c = c || b;
    g[a] = c;
    for (var e = 0, f = d.length; f > e; e++) {
      c[d[e]] = c[d[e]] || {}, c = c[d[e]];
    }
    return c
  };
  var h = a.config = {context: "app", dir: "js", isAjax: !0}, i = function () {
    this.singletons = {}, this.constructors = {}, this.eventMap = {}, this.kvMap = {}
  };
  i.prototype = {createInstance: function (a) {
    var b = s.call(arguments, 1), c = new a(b);
    return c[h.context] = this, c
  }, getSingleton: function (a) {
    if (!(a in this.singletons)) {
      if (!(a in this.constructors)) {
        throw new Error("no such class");
      }
      this.singletons[a] = new this.constructors[a]
    }
    return this.singletons[a]
  }, getValue: function (a) {
    return this.kvMap[a]
  }, init: function (a) {
    a = f(a) ? a : [a];
    for (var b in g) {
      for (var c = 0, d = a.length; d > c; c++) {
        var i = new RegExp("^" + a[c]);
        if (!i.test(b)) {
          for (var j = b.split("."), k = g[b], l = 0, m = j.length; m > l; l++) {
            k = k[j[l]];
          }
          for (var n in k) {
            e(k[n]) && (k[n].prototype[h.context] = this)
          }
        }
      }
    }
  }, injectInto: function (a) {
    e(a) ? a.prototype[h.context] = this : a[h.context] = this
  }, mapEvent: function (a, b, c) {
    this.eventMap[a] = this.eventMap.event || [], this.eventMap[a].push({command: b, context: c})
  }, mapSingleton: function (a, b) {
    e(a) ? this.constructors[b] = a : this.singletons[b] = a
  }, mapValue: function (a, b) {
    this.kvMap[a] = b
  }, start: function (a) {
    r.start(a, this)
  }, trigger: function (a) {
    var b = Array.prototype.slice.call(arguments, 1), c = this.eventMap[a];
    b.push(this);
    for (var d = 0, e = c.length; e > d; d++) {
      var f = c[d];
      f.command.apply(f.context, b)
    }
  }};
  var j = /(import|extend) ((\w+\.)+(\w+))/gi, k = -1, l = [], m = [
  ], n = {}, o = document.getElementsByTagName("head")[0] || document.documentElement, p = o.getElementsByTagName("base")[0], q = new XMLHttpRequest;
  q.onload = function () {
    l[k].content = this.response, r.parse(this.response), r.loadNext()
  };
  var r = {createNodes: function () {
    for (var a = 0, b = m.length; b > a; a++) {
      for (var c = 0; b > c && l[c].fullname !== m[a]; c++) {
        ;
      }
      d(l[c].content, l[c].className), l.splice(c, 1)
    }
    "func"in n && n.func.call(n.context)
  }, loadNext: function () {
    return k++, k >= l.length ? (this.createNodes(), void 0) : (q.open("get", c(l[k].fullname)), q.send(), void 0)
  }, parse: function (a) {
    e(a) && (a = a.toString());
    var b = a.match(j);
    if (b) {
      for (var c = 0, d = b.length; d > c; c++) {
        var f = b[c].slice(7);
        if (-1 === m.indexOf(f)) {
          var g = {fullname: f, className: f.slice(f.lastIndexOf(".") + 1), type: b[c].substr(0, 6), content: ""};
          if (l.push(g), "import" === g.type) {
            m.push(f);
          } else {
            for (var h = l[k].fullname, i = 0; m[i] !== h;) {
              i++;
            }
            m.splice(i, 0, f)
          }
        }
      }
    }
  }, reset: function () {
    m = [], l = []
  }, start: function (a, b) {
    this.reset(), n = {func: a, context: b}, this.parse(a), this.loadNext()
  }}, s = Array.prototype.slice
}({}, function () {
  return this
}());
/*
 //@ sourceMappingURL=Nervenet.min.map
 */